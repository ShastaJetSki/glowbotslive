<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Family Wheel Prototype</title>
  <style>
    :root{
      --wheel-size: 420px;
      --rim: 12px;
      --bg: #0b1020;
      --panel: #101a33;
      --text: #e8eeff;
      --muted: #9bb0ff;
      --shadow: 0 18px 45px rgba(0,0,0,.45);
    }
    *{box-sizing:border-box}
    body{
      margin:0; min-height:100vh; display:grid; place-items:center;
      background: radial-gradient(1200px 800px at 30% 20%, #1a2b6b 0%, var(--bg) 60%);
      color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    .app{
      width:min(980px, 94vw);
      display:grid;
      gap:18px;
      grid-template-columns: 1.1fr .9fr;
      align-items:center;
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 18px;
      box-shadow: var(--shadow);
      padding:16px;
    }
    .stage{
      display:grid;
      place-items:center;
      position:relative;
      padding:18px 10px 22px;
      user-select:none;
      touch-action:none; /* important for pointer drag */
    }
    .wheel-wrap{
      width:var(--wheel-size);
      height:var(--wheel-size);
      position:relative;
      display:grid;
      place-items:center;
    }
    .wheel{
      width:100%;
      height:100%;
      border-radius:50%;
      position:relative;
      background:
        conic-gradient(
          #ff4d7d 0deg 72deg,
          #28d7ff 72deg 144deg,
          #ffd24a 144deg 216deg,
          #7cff7c 216deg 288deg,
          #b48cff 288deg 360deg
        );
      box-shadow: 0 10px 30px rgba(0,0,0,.55);
      border: var(--rim) solid rgba(255,255,255,.14);
      transform: rotate(0deg);
      will-change: transform;
      cursor: grab;
      overflow:hidden;
    }
    .wheel:active{ cursor: grabbing; }

    /* subtle inner rings */
    .wheel::before{
      content:"";
      position:absolute; inset: 16px;
      border-radius:50%;
      border:1px solid rgba(255,255,255,.18);
      box-shadow: inset 0 0 0 10px rgba(0,0,0,.10);
      pointer-events:none;
    }
    .wheel::after{
      content:"";
      position:absolute; inset: 56px;
      border-radius:50%;
      background: radial-gradient(circle at 35% 30%, rgba(255,255,255,.24), rgba(255,255,255,.06) 55%, rgba(0,0,0,.20));
      pointer-events:none;
    }

    /* center cap */
    .cap{
      position:absolute;
      width:92px; height:92px;
      border-radius:50%;
      background: linear-gradient(180deg, rgba(255,255,255,.22), rgba(255,255,255,.06));
      border:1px solid rgba(255,255,255,.18);
      box-shadow: 0 12px 24px rgba(0,0,0,.45), inset 0 0 0 10px rgba(0,0,0,.12);
      display:grid; place-items:center;
      z-index:5;
      pointer-events:none;
    }
    .cap span{
      font-weight:800;
      letter-spacing:.4px;
      font-size:12px;
      color:rgba(255,255,255,.92);
      text-transform:uppercase;
    }

    /* pointer */
    .pointer{
      position:absolute;
      top:-6px;
      left:50%;
      transform: translateX(-50%);
      width:0; height:0;
      border-left:18px solid transparent;
      border-right:18px solid transparent;
      border-bottom:38px solid rgba(255,255,255,.92);
      filter: drop-shadow(0 10px 10px rgba(0,0,0,.45));
      z-index:6;
    }
    .pointer::after{
      content:"";
      position:absolute;
      left:-10px; top:8px;
      width:0; height:0;
      border-left:10px solid transparent;
      border-right:10px solid transparent;
      border-bottom:22px solid rgba(0,0,0,.22);
    }

    /* faces around rim */
    .face{
      position:absolute;
      width:74px; height:74px;
      border-radius:16px;
      background: rgba(255,255,255,.14);
      border:1px solid rgba(255,255,255,.18);
      backdrop-filter: blur(6px);
      display:grid;
      place-items:center;
      box-shadow: 0 10px 20px rgba(0,0,0,.35);
      transform-origin: 50% 50%;
      z-index:4;
      pointer-events:none; /* wheel drag should still work */
    }
    .face svg{ width:62px; height:62px; display:block; }

    /* controls */
    .controls{
      display:flex; gap:10px; flex-wrap:wrap;
      justify-content:center;
      margin-top:14px;
    }
    button{
      appearance:none;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.08);
      color: var(--text);
      padding:10px 12px;
      border-radius:12px;
      font-weight:700;
      cursor:pointer;
      transition: transform .08s ease, background .15s ease;
    }
    button:hover{ background: rgba(255,255,255,.12); }
    button:active{ transform: translateY(1px) scale(.99); }

    .hint{
      color: rgba(255,255,255,.74);
      font-size: 13px;
      line-height:1.35;
      margin: 8px 6px 0;
      text-align:center;
    }

    .side{
      display:grid;
      gap:14px;
    }
    .title{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:12px;
    }
    .title h1{
      font-size:18px;
      margin:0;
      letter-spacing:.2px;
    }
    .title p{
      margin:6px 0 0;
      color: rgba(255,255,255,.70);
      font-size:13px;
    }
    .readout{
      display:grid;
      gap:10px;
    }
    .row{
      display:flex;
      justify-content:space-between;
      gap:10px;
      padding:10px 12px;
      border-radius:12px;
      background: rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.10);
      font-size:13px;
    }
    .row b{ color: rgba(255,255,255,.92); }
    .small{
      color: rgba(255,255,255,.68);
      font-size:12px;
      line-height:1.35;
      margin:0;
    }

    @media (max-width: 880px){
      .app{ grid-template-columns: 1fr; }
      :root{ --wheel-size: min(420px, 86vw); }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="card stage">
      <div class="wheel-wrap" id="wheelWrap">
        <div class="pointer" aria-hidden="true"></div>

        <div class="wheel" id="wheel" role="application" aria-label="Family wheel spinner">
          <!-- faces injected by JS -->
        </div>

        <div class="cap" aria-hidden="true"><span>SPIN</span></div>
      </div>

      <div class="controls">
        <button id="leftBtn" title="Spin backward (‚Üê)">‚üµ Back</button>
        <button id="spinBtn" title="Random spin">üé≤ Random Spin</button>
        <button id="rightBtn" title="Spin forward (‚Üí)">Forward ‚ü∂</button>
        <button id="stopBtn" title="Stop quickly">‚õî Stop</button>
      </div>

      <div class="hint">
        Grab the wheel and fling it, or use the buttons / keyboard arrows (‚Üê ‚Üí).<br/>
        This is a concept prototype (faces are placeholder icons).
      </div>
    </div>

    <div class="card side">
      <div class="title">
        <div>
          <h1>Family Wheel Prototype</h1>
          <p>5 slices ‚Ä¢ 5 faces ‚Ä¢ inertia drag spin</p>
        </div>
      </div>

      <div class="readout">
        <div class="row"><span>Rotation</span><b id="rotOut">0¬∞</b></div>
        <div class="row"><span>Angular velocity</span><b id="velOut">0</b></div>
        <div class="row"><span>Pointer slice</span><b id="sliceOut">‚Äî</b></div>
      </div>

      <p class="small">
        Want real photos? Replace the SVG face icons with &lt;img&gt; tags, or generate avatars per family member.
        The placement logic already puts one icon on each slice near the rim.
      </p>
    </div>
  </div>

<script>
(() => {
  const wheel = document.getElementById('wheel');
  const wrap  = document.getElementById('wheelWrap');

  const rotOut   = document.getElementById('rotOut');
  const velOut   = document.getElementById('velOut');
  const sliceOut = document.getElementById('sliceOut');

  const leftBtn  = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');
  const spinBtn  = document.getElementById('spinBtn');
  const stopBtn  = document.getElementById('stopBtn');

  // --- Config ---
  const members = [
    { name: "Mom",   accent: "#ff4d7d", hair: "#3a2a1a" },
    { name: "Dad",   accent: "#28d7ff", hair: "#1e1e1e" },
    { name: "Sis",   accent: "#ffd24a", hair: "#8b3dff" },
    { name: "Bro",   accent: "#7cff7c", hair: "#ff7a00" },
    { name: "Nana",  accent: "#b48cff", hair: "#c7c7c7" },
  ];
  const N = members.length;              // 5
  const sliceDeg = 360 / N;              // 72
  const friction = 0.985;                // inertia decay per frame
  const stopEps  = 0.02;                 // velocity threshold to stop

  // --- State ---
  let angleDeg = 0;                      // wheel rotation degrees
  let vel = 0;                           // degrees per frame (approx)
  let isDragging = false;
  let dragStartAngle = 0;
  let dragStartDeg = 0;
  let lastMoveT = 0;
  let lastMoveDeg = 0;

  // --- Helpers ---
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const normDeg = (d) => ((d % 360) + 360) % 360;

  function pointerSliceIndex(currentAngleDeg){
    // Pointer is at "top" (0deg). Wheel rotates, so slice under pointer is based on inverse rotation.
    // We consider slices centered at: 0, 72, 144...
    const a = normDeg(-currentAngleDeg); // invert wheel rotation
    const idx = Math.floor((a + sliceDeg/2) / sliceDeg) % N;
    return idx;
  }

  function updateUI(){
    wheel.style.transform = `rotate(${angleDeg}deg)`;
    rotOut.textContent = `${normDeg(angleDeg).toFixed(1)}¬∞`;
    velOut.textContent = `${vel.toFixed(2)}`;
    const idx = pointerSliceIndex(angleDeg);
    sliceOut.textContent = members[idx]?.name ?? "‚Äî";
  }

  function getAngleFromCenter(clientX, clientY){
    const r = wrap.getBoundingClientRect();
    const cx = r.left + r.width/2;
    const cy = r.top + r.height/2;
    const dx = clientX - cx;
    const dy = clientY - cy;
    // atan2: 0 at +x; convert so 0 at top, increasing clockwise
    const rad = Math.atan2(dy, dx);
    let deg = rad * (180/Math.PI);
    deg = deg + 90; // rotate reference so "top" is 0
    return deg;
  }

  function injectFaces(){
    // Remove old faces
    wheel.querySelectorAll('.face').forEach(el => el.remove());

    // Place 5 face icons around rim in the middle of each slice.
    // The faces should rotate with the wheel (so they are children inside the wheel).
    // We'll position them with polar coordinates relative to the wheel box.
    const rect = wheel.getBoundingClientRect();
    const size = rect.width || parseFloat(getComputedStyle(wheel).width);
    const radius = size * 0.38; // where faces sit (near rim but inside)
    const center = size / 2;

    members.forEach((m, i) => {
      const mid = i * sliceDeg + sliceDeg/2; // slice midpoint angle (deg), 0 at top (after we adjust)
      // convert to standard x/y: 0 at top, clockwise
      const rad = (mid - 90) * Math.PI/180; // -90 to convert to 0 at +x for cos/sin
      const x = center + radius * Math.cos(rad);
      const y = center + radius * Math.sin(rad);

      const face = document.createElement('div');
      face.className = 'face';
      face.style.left = `${x}px`;
      face.style.top  = `${y}px`;
      face.style.transform = `translate(-50%, -50%) rotate(${-mid}deg)`; 
      // rotate face upright-ish relative to slice (optional)

      face.innerHTML = makeFaceSVG(m);
      wheel.appendChild(face);
    });
  }

  function makeFaceSVG(member){
    // Simple cartoon SVG face (placeholder icon) with different hair/accent.
    // You can swap this for <img src="..."> later.
    const skin = "#ffd7b3";
    const blush = "rgba(255, 90, 120, .35)";
    const eye = "#1b1b1b";
    const mouth = "#7a2f2f";

    return `
    <svg viewBox="0 0 64 64" aria-label="${member.name} face">
      <!-- accent ring -->
      <circle cx="32" cy="32" r="30" fill="${member.accent}" opacity="0.9"/>
      <circle cx="32" cy="32" r="26" fill="rgba(255,255,255,.14)"/>
      <!-- hair -->
      <path d="M14 28c1-10 8-18 18-18s17 8 18 18c-4-6-10-9-18-9s-14 3-18 9z"
            fill="${member.hair}" opacity="0.95"/>
      <!-- face -->
      <circle cx="32" cy="34" r="16" fill="${skin}"/>
      <!-- cheeks -->
      <circle cx="24" cy="38" r="4" fill="${blush}"/>
      <circle cx="40" cy="38" r="4" fill="${blush}"/>
      <!-- eyes -->
      <circle cx="26" cy="32" r="2.2" fill="${eye}"/>
      <circle cx="38" cy="32" r="2.2" fill="${eye}"/>
      <!-- smile -->
      <path d="M26 41c2.5 3 9.5 3 12 0" fill="none" stroke="${mouth}" stroke-width="2.4" stroke-linecap="round"/>
      <!-- label -->
      <text x="32" y="60" text-anchor="middle" font-size="8.5" font-weight="800" fill="rgba(255,255,255,.92)"
            style="letter-spacing:.6px">${member.name.toUpperCase()}</text>
    </svg>`;
  }

  // --- Physics loop ---
  let rafId = null;
  function tick(){
    if (!isDragging){
      vel *= friction;
      if (Math.abs(vel) < stopEps) vel = 0;
      angleDeg += vel;
      updateUI();
    }
    rafId = requestAnimationFrame(tick);
  }

  function startLoop(){
    if (rafId) cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(tick);
  }

  // --- Drag interactions ---
  function onPointerDown(e){
    // Only primary button for mouse
    if (e.pointerType === 'mouse' && e.button !== 0) return;
    wheel.setPointerCapture?.(e.pointerId);

    isDragging = true;
    vel = 0;

    dragStartDeg = angleDeg;
    dragStartAngle = getAngleFromCenter(e.clientX, e.clientY);

    lastMoveT = performance.now();
    lastMoveDeg = angleDeg;
  }

  function onPointerMove(e){
    if (!isDragging) return;

    const a = getAngleFromCenter(e.clientX, e.clientY);
    const delta = a - dragStartAngle;

    angleDeg = dragStartDeg + delta;

    // Estimate velocity from recent movement
    const now = performance.now();
    const dt = Math.max(1, now - lastMoveT);
    const ddeg = angleDeg - lastMoveDeg;

    // Convert to degrees per frame-ish (assuming ~16ms frame)
    vel = (ddeg / dt) * 16;

    lastMoveT = now;
    lastMoveDeg = angleDeg;

    updateUI();
  }

  function onPointerUp(){
    if (!isDragging) return;
    isDragging = false;
    // inertia continues with current vel
  }

  // --- Buttons / keyboard ---
  function nudge(direction){
    // direction: -1 back, +1 forward
    vel += direction * 8; // kick
    vel = clamp(vel, -45, 45);
  }

  leftBtn.addEventListener('click', () => nudge(-1));
  rightBtn.addEventListener('click', () => nudge(1));

  spinBtn.addEventListener('click', () => {
    // random strong spin
    const dir = Math.random() < 0.5 ? -1 : 1;
    vel = dir * (20 + Math.random()*20);
  });

  stopBtn.addEventListener('click', () => {
    vel *= 0.25;
    if (Math.abs(vel) < 1) vel = 0;
  });

  window.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft') nudge(-1);
    if (e.key === 'ArrowRight') nudge(1);
  });

  // --- init ---
  wheel.addEventListener('pointerdown', onPointerDown);
  window.addEventListener('pointermove', onPointerMove);
  window.addEventListener('pointerup', onPointerUp);
  window.addEventListener('pointercancel', onPointerUp);

  // Inject faces after layout (so wheel has size)
  requestAnimationFrame(() => {
    injectFaces();
    updateUI();
    startLoop();
  });

  // Re-position faces on resize (responsive)
  window.addEventListener('resize', () => {
    injectFaces();
    updateUI();
  });

})();
</script>
</body>
</html>
