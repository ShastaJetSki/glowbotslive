<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Family Wheel â€“ 10 Photos + Center Select + Clicky Detents</title>

<style>
  :root{
    --size: 520px;
    --bg:#0b1020;
    --text:#e8eeff;
    --panel: rgba(255,255,255,.06);
    --border: rgba(255,255,255,.12);
    --shadow: 0 18px 45px rgba(0,0,0,.45);
  }
  *{box-sizing:border-box}
  body{
    margin:0; min-height:100vh; display:grid; place-items:center;
    background: radial-gradient(1200px 800px at 30% 20%, #1a2b6b 0%, var(--bg) 60%);
    color:var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  }
  .wrap{
    width:min(1100px, 95vw);
    display:grid;
    grid-template-columns: 1.1fr .9fr;
    gap:18px;
    align-items:center;
  }
  .card{
    background: linear-gradient(180deg, var(--panel), rgba(255,255,255,.02));
    border:1px solid var(--border);
    border-radius:18px;
    box-shadow: var(--shadow);
    padding:16px;
  }
  .stage{ display:grid; place-items:center; user-select:none; touch-action:none; }

  .wheelShell{
    width:var(--size);
    height:var(--size);
    position:relative;
    display:grid;
    place-items:center;
  }

  canvas{
    width:100%;
    height:100%;
    display:block;
    border-radius:50%;
  }

  .pointer{
    position:absolute;
    top:-8px;
    left:50%;
    transform:translateX(-50%);
    width:0;height:0;
    border-left:20px solid transparent;
    border-right:20px solid transparent;
    border-bottom:44px solid rgba(255,255,255,.95);
    filter: drop-shadow(0 12px 12px rgba(0,0,0,.45));
    z-index:10;
    pointer-events:none;
  }
  .pointer::after{
    content:"";
    position:absolute;
    left:-11px; top:10px;
    width:0;height:0;
    border-left:11px solid transparent;
    border-right:11px solid transparent;
    border-bottom:26px solid rgba(0,0,0,.20);
  }

  /* center selected avatar */
  .center{
    position:absolute;
    width: 210px;
    height: 210px;
    border-radius:50%;
    background: linear-gradient(180deg, rgba(255,255,255,.22), rgba(255,255,255,.06));
    border:1px solid rgba(255,255,255,.18);
    box-shadow: 0 16px 35px rgba(0,0,0,.60), inset 0 0 0 14px rgba(0,0,0,.12);
    display:grid;
    place-items:center;
    z-index:9;
    pointer-events:none;
  }
  .center img{
    width: 162px;
    height: 162px;
    border-radius:50%;
    object-fit:cover;
    object-position: 50% 22%;
    border:1px solid rgba(255,255,255,.14);
    box-shadow: 0 12px 24px rgba(0,0,0,.35);
    background: rgba(0,0,0,.20);
  }
  .center .label{
    position:absolute;
    bottom:-18px;
    padding:6px 14px;
    border-radius:999px;
    font-weight:900;
    font-size:13px;
    letter-spacing:.6px;
    background: rgba(0,0,0,.45);
    border:1px solid rgba(255,255,255,.16);
    color: rgba(255,255,255,.92);
    white-space:nowrap;
  }

  .controls{
    display:flex;
    justify-content:center;
    gap:10px;
    flex-wrap:wrap;
    margin-top:14px;
  }
  button{
    appearance:none;
    border:1px solid rgba(255,255,255,.16);
    background: rgba(255,255,255,.08);
    color: var(--text);
    padding:10px 12px;
    border-radius:12px;
    font-weight:800;
    cursor:pointer;
    transition: transform .08s ease, background .15s ease;
  }
  button:hover{ background: rgba(255,255,255,.12); }
  button:active{ transform: translateY(1px) scale(.99); }

  .hint{
    margin-top:10px;
    text-align:center;
    color: rgba(255,255,255,.72);
    font-size:13px;
    line-height:1.35;
  }

  .side h2{ margin:0; font-size:16px; letter-spacing:.2px; }
  .side p{ margin:8px 0 0; color: rgba(255,255,255,.72); font-size:13px; line-height:1.35; }
  .row{
    margin-top:12px;
    display:flex;
    justify-content:space-between;
    gap:10px;
    padding:10px 12px;
    border-radius:12px;
    background: rgba(0,0,0,.18);
    border:1px solid rgba(255,255,255,.10);
    font-size:13px;
  }
  .row b{ color: rgba(255,255,255,.92); }

  @media (max-width: 920px){
    .wrap{ grid-template-columns: 1fr; }
    :root{ --size: min(520px, 88vw); }
    .center{ width: 190px; height: 190px; }
    .center img{ width: 148px; height: 148px; }
  }
</style>
</head>

<body>
  <div class="wrap">
    <div class="card stage">
      <div class="wheelShell" id="shell">
        <div class="pointer"></div>
        <canvas id="wheelCanvas"></canvas>

        <div class="center" aria-hidden="true">
          <img id="centerImg" alt="Selected family member" />
          <div class="label" id="centerLabel">â€”</div>
        </div>
      </div>

      <div class="controls">
        <button id="backBtn" title="Spin backward (â†)">âŸµ Back</button>
        <button id="spinBtn" title="Random spin">ðŸŽ² Random</button>
        <button id="fwdBtn" title="Spin forward (â†’)">Forward âŸ¶</button>
        <button id="stopBtn" title="Stop quickly">â›” Stop</button>
      </div>

      <div class="hint">
        Grab & fling the wheel. It has <b>tension + clicky detents</b> (Price-Is-Right style).<br/>
        Each slice image is wedge-masked. <b>Head toward rim</b>, <b>chest toward center</b>. Center shows selected.
      </div>
    </div>

    <div class="card side">
      <h2>Wheel debug</h2>
      <div class="row"><span>Rotation</span> <b id="rotOut">0Â°</b></div>
      <div class="row"><span>Angular velocity</span> <b id="velOut">0</b></div>
      <div class="row"><span>Selected</span> <b id="selOut">â€”</b></div>
      <p>
        Put your 10 images in the <b>same folder</b> as this HTML file and name them exactly:
        <code>member01.png</code> ... <code>member10.png</code>.
      </p>
    </div>
  </div>

<script>
(() => {
  // ============================================================
  // IMPORTANT:
  // Put your 10 images in the same folder as this HTML file:
  //   member01.png, member02.png, ... member10.png
  // ============================================================

  const MEMBERS = [
    { name: "Member 01", src: "member01.png" },
    { name: "Member 02", src: "member02.png" },
    { name: "Member 03", src: "member03.png" },
    { name: "Member 04", src: "member04.png" },
    { name: "Member 05", src: "member05.png" },
    { name: "Member 06", src: "member06.png" },
    { name: "Member 07", src: "member07.png" },
    { name: "Member 08", src: "member08.png" },
    { name: "Member 09", src: "member09.png" },
    { name: "Member 10", src: "member10.png" },
  ];

  // ---- DOM
  const canvas = document.getElementById("wheelCanvas");
  const shell  = document.getElementById("shell");
  const centerImg = document.getElementById("centerImg");
  const centerLabel = document.getElementById("centerLabel");

  const rotOut = document.getElementById("rotOut");
  const velOut = document.getElementById("velOut");
  const selOut = document.getElementById("selOut");

  const backBtn = document.getElementById("backBtn");
  const fwdBtn  = document.getElementById("fwdBtn");
  const spinBtn = document.getElementById("spinBtn");
  const stopBtn = document.getElementById("stopBtn");

  // ---- Wheel constants
  const N = MEMBERS.length;
  const TAU = Math.PI * 2;
  const slice = TAU / N;

  // Colors for slice backgrounds (under the photos)
  const sliceColors = [
    "#ff4d7d","#28d7ff","#ffd24a","#7cff7c","#b48cff",
    "#ff8f4d","#4dd8a0","#5c7cff","#ff6bdc","#c2ff4d"
  ];

  // ---- Physics / feel tuning (Price-Is-Right-ish detents)
  const friction = 0.985;     // overall spin decay
  const maxVel = 0.35;        // radians per frame-ish
  const detentStrength = 0.018; // how hard it "pulls" into notch
  const detentDamping  = 0.10;  // reduces oscillation
  const clickThreshold = 0.45;  // how close to notch counts as "clicked" (fraction of slice half-width)

  // ---- Image placement / cropping inside wedge
  const coverCropBias = 0.58; // <â€” move image outward (toward rim). 0.5 center, 0.62 more head-out
  const imgScale = 1.18;      // >1 zoom in a bit to fill wedge better

  // ---- State
  let angle = 0;              // radians (wheel rotation)
  let vel = 0;                // radians per frame approx
  let dragging = false;
  let dragStartAngle = 0;
  let dragStartRot = 0;
  let lastPointerIdx = -1;

  // Click sound (tiny WebAudio "tick")
  let audioCtx = null;
  function tickSound(intensity = 1){
    try{
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const t = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = "square";
      o.frequency.setValueAtTime(950 + 250*intensity, t);
      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(0.08 * intensity, t + 0.005);
      g.gain.exponentialRampToValueAtTime(0.0001, t + 0.03);
      o.connect(g).connect(audioCtx.destination);
      o.start(t);
      o.stop(t + 0.04);
    }catch(e){}
  }

  // ---- Canvas setup
  const ctx = canvas.getContext("2d");

  function resize(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const r = shell.getBoundingClientRect();
    canvas.width  = Math.floor(r.width * dpr);
    canvas.height = Math.floor(r.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  // ---- Load images
  function loadImages(){
    return Promise.all(MEMBERS.map(m => new Promise((resolve) => {
      const im = new Image();
      im.onload = () => resolve({ ...m, img: im, ok: true });
      im.onerror = () => resolve({ ...m, img: null, ok: false });
      im.src = m.src;
    })));
  }

  // If any image fails, we REMOVE it (as you requested: delete incomplete image file usage).
  function filterOk(items){
    const ok = items.filter(x => x.ok && x.img);
    return ok;
  }

  function normRad(a){
    a = a % TAU;
    if (a < 0) a += TAU;
    return a;
  }

  // Pointer is at top (-90deg). Determine slice under pointer based on inverse rotation.
  function pointerIndex(){
    const a = normRad(-angle);
    // shift by half-slice so boundaries behave naturally
    return Math.floor((a + slice/2) / slice) % MEMBERS_RUNTIME.length;
  }

  // Nearest detent target (we snap so slice center aligns with pointer at top)
  function nearestDetentTarget(){
    const a = normRad(angle);
    // We want angle values where slice centers align with pointer.
    // When angle = k*slice, the slice center at pointer is stable in our index calc.
    const k = Math.round(a / slice);
    return k * slice;
  }

  // Signed smallest angle difference [-pi, pi]
  function angDiff(a, b){
    let d = (a - b) % TAU;
    if (d > Math.PI) d -= TAU;
    if (d < -Math.PI) d += TAU;
    return d;
  }

  function drawWheel(){
    const w = shell.clientWidth;
    const h = shell.clientHeight;
    const cx = w/2, cy = h/2;

    // radii
    const outerR = Math.min(w,h)/2 - 8;
    const innerR = outerR * 0.34; // center hole area under hub
    const rimR   = outerR - 4;

    ctx.clearRect(0,0,w,h);

    // Outer subtle shadow ring
    ctx.save();
    ctx.translate(cx, cy);
    ctx.beginPath();
    ctx.arc(0,0,outerR,0,TAU);
    ctx.fillStyle = "rgba(0,0,0,.18)";
    ctx.fill();
    ctx.restore();

    // Slices
    for (let i=0; i<MEMBERS_RUNTIME.length; i++){
      const start = angle + i*slice - slice/2;
      const end   = start + slice;

      // Background wedge (color under photo)
      ctx.save();
      ctx.translate(cx, cy);
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.arc(0,0,rimR,start,end);
      ctx.closePath();
      ctx.fillStyle = sliceColors[i % sliceColors.length];
      ctx.globalAlpha = 0.85;
      ctx.fill();
      ctx.restore();

      // Photo wedge (clipped)
      const img = MEMBERS_RUNTIME[i].img;
      if (img){
        drawWedgeImage(img, cx, cy, innerR, rimR, start, end, i);
      }

      // Slice separator line
      ctx.save();
      ctx.translate(cx, cy);
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.arc(0,0,rimR,start,end);
      ctx.closePath();
      ctx.strokeStyle = "rgba(255,255,255,.12)";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();
    }

    // Inner ring overlay (gives depth)
    ctx.save();
    ctx.translate(cx, cy);
    ctx.beginPath();
    ctx.arc(0,0,innerR+10,0,TAU);
    ctx.strokeStyle = "rgba(255,255,255,.18)";
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.restore();

    // Rim highlight
    ctx.save();
    ctx.translate(cx, cy);
    ctx.beginPath();
    ctx.arc(0,0,outerR,0,TAU);
    ctx.strokeStyle = "rgba(255,255,255,.14)";
    ctx.lineWidth = 12;
    ctx.stroke();
    ctx.restore();
  }

  // Draw an image clipped to a wedge.
  // Orientation rule:
  // - "Head toward rim" => top of photo toward outer radius
  // - "Chest toward center" => bottom of photo toward inner radius
  function drawWedgeImage(img, cx, cy, innerR, outerR, start, end, idx){
    // Create wedge clip
    ctx.save();
    ctx.translate(cx, cy);
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.arc(0,0,outerR,start,end);
    ctx.closePath();
    ctx.clip();

    // Rotate canvas so we can draw the image "upright" within the wedge
    const mid = (start + end) / 2;

    // In our coordinate system, angle 0 is at +x. Pointer is at top.
    // We'll rotate so "outward" (toward rim) is "up" in local coordinates.
    ctx.rotate(mid);

    // Local wedge bounds: place a tall rectangle spanning inner->outer
    const span = outerR - innerR;
    const rectH = span * 1.08;
    const rectW = rectH * 0.78; // portrait-ish

    // Position the rect outward so heads favor rim:
    const yTop = -(innerR + span*coverCropBias);
    const rectY = yTop - rectH*0.50;
    const rectX = -rectW/2;

    // Cover draw (like CSS object-fit: cover)
    const sW = img.naturalWidth;
    const sH = img.naturalHeight;

    // target box size (scaled a bit to ensure no gaps)
    const tW = rectW * imgScale;
    const tH = rectH * imgScale;

    const scale = Math.max(tW / sW, tH / sH);
    const dW = sW * scale;
    const dH = sH * scale;

    // Center the image in the rect
    const dx = rectX + (rectW - dW)/2;
    const dy = rectY + (rectH - dH)/2;

    ctx.globalAlpha = 0.98;
    ctx.drawImage(img, dx, dy, dW, dH);

    // Gentle vignette inside wedge
    const grad = ctx.createRadialGradient(0, yTop, innerR*0.2, 0, yTop, outerR*0.95);
    grad.addColorStop(0, "rgba(0,0,0,0.00)");
    grad.addColorStop(1, "rgba(0,0,0,0.18)");
    ctx.fillStyle = grad;
    ctx.fillRect(-outerR, -outerR, outerR*2, outerR*2);

    ctx.restore();
  }

  function updateCenter(idx){
    const m = MEMBERS_RUNTIME[idx];
    if (!m) return;
    centerImg.src = m.src;
    centerLabel.textContent = m.name;
    selOut.textContent = m.name;
  }

  function updateDebug(){
    rotOut.textContent = `${(normRad(angle) * 180/Math.PI).toFixed(1)}Â°`;
    velOut.textContent = `${vel.toFixed(3)}`;
  }

  // Pointer interaction
  function getAngleFromCenter(clientX, clientY){
    const r = shell.getBoundingClientRect();
    const cx = r.left + r.width/2;
    const cy = r.top + r.height/2;
    const dx = clientX - cx;
    const dy = clientY - cy;
    // angle with 0 at top, clockwise positive:
    return Math.atan2(dy, dx) + Math.PI/2;
  }

  // Buttons
  function nudge(dir){
    vel += dir * 0.085;
    vel = Math.max(-maxVel, Math.min(maxVel, vel));
  }

  backBtn.addEventListener("click", () => nudge(-1));
  fwdBtn.addEventListener("click",  () => nudge(1));
  spinBtn.addEventListener("click", () => {
    const dir = Math.random() < 0.5 ? -1 : 1;
    vel = dir * (0.18 + Math.random()*0.20);
  });
  stopBtn.addEventListener("click", () => {
    vel *= 0.20;
    if (Math.abs(vel) < 0.01) vel = 0;
  });

  window.addEventListener("keydown", (e) => {
    if (e.key === "ArrowLeft") nudge(-1);
    if (e.key === "ArrowRight") nudge(1);
  });

  // Drag spin
  shell.addEventListener("pointerdown", (e) => {
    if (e.pointerType === "mouse" && e.button !== 0) return;
    shell.setPointerCapture?.(e.pointerId);
    dragging = true;
    vel = 0;
    dragStartRot = angle;
    dragStartAngle = getAngleFromCenter(e.clientX, e.clientY);
  });

  window.addEventListener("pointermove", (e) => {
    if (!dragging) return;
    const a = getAngleFromCenter(e.clientX, e.clientY);
    angle = dragStartRot + (a - dragStartAngle);
    render();
  });

  window.addEventListener("pointerup", () => { dragging = false; });
  window.addEventListener("pointercancel", () => { dragging = false; });

  // Clicky detents + tension (spring to nearest notch when slow-ish)
  function applyDetents(){
    // Only apply when not dragging
    if (dragging) return;

    // Basic friction
    vel *= friction;

    // Detent spring toward nearest notch (stronger when slower)
    const target = nearestDetentTarget();
    const err = angDiff(angle, target); // angle - target

    // Spring force opposite error
    const spring = (-err) * detentStrength;

    // Damping based on velocity
    const damp = -vel * detentDamping;

    // Blend: detent is stronger when velocity is low
    const slowFactor = Math.max(0, 1 - (Math.abs(vel) / 0.20)); // 0..1
    vel += (spring + damp) * (0.35 + 0.65*slowFactor);

    // Clamp
    vel = Math.max(-maxVel, Math.min(maxVel, vel));

    // Update angle
    angle += vel;

    // Click sound & slight "step" feel when crossing to a new slice under pointer
    const idx = pointerIndex();
    if (idx !== lastPointerIdx){
      lastPointerIdx = idx;
      updateCenter(idx);

      // click intensity based on speed
      const intensity = Math.min(1, 0.3 + Math.abs(vel) * 2.5);
      tickSound(intensity);

      // small velocity loss on click (feels like hitting a peg)
      vel *= (0.86 - 0.10 * Math.min(1, Math.abs(vel)*3));
    }
  }

  function render(){
    drawWheel();
    updateDebug();
  }

  function loop(){
    applyDetents();
    render();
    requestAnimationFrame(loop);
  }

  // Runtime members list after filtering broken images (per your request)
  let MEMBERS_RUNTIME = [];

  // Init
  function initWith(images){
    MEMBERS_RUNTIME = images;

    // If any failed, we re-calc N/slice by using MEMBERS_RUNTIME
    // (keeps wheel valid and avoids referencing incomplete images)
    if (MEMBERS_RUNTIME.length < 2){
      // Not enough images loaded to show a wheel
      centerLabel.textContent = "Missing images";
      selOut.textContent = "Missing images";
      return;
    }

    // Set initial selection
    lastPointerIdx = pointerIndex();
    updateCenter(lastPointerIdx);

    resize();
    render();
    loop();
  }

  window.addEventListener("resize", () => { resize(); render(); });

  loadImages().then(items => {
    const ok = filterOk(items);

    // Rename the display names if you want, but keep the image order.
    // (You can edit MEMBERS array at the top.)
    initWith(ok);
  });
})();
</script>
</body>
</html>
